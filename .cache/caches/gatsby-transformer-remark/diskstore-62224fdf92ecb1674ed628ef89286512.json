{"expireTime":9007200870884087000,"key":"transformer-remark-markdown-html-48972d3a68c2db498de5c79a070d38b6-gatsby-remark-custom-blocks-/SonarQubeChineseDoc8.1","val":"<h2>Building your plugin</h2>\n<h3>Prerequisites</h3>\n<p>To build a plugin, you need Java 8 and Maven 3.1 (or greater). Gradle can also be used thanks to <a href=\"https://github.com/iwarapter/gradle-sonar-packaging-plugin\">https://github.com/iwarapter/gradle-sonar-packaging-plugin</a>. Note that this Gradle plugin is not officially supported by SonarSource.</p>\n<h3>Create a Maven Project</h3>\n<p>The recommended way to start is by duplicating the plugin example project: <a href=\"https://github.com/SonarSource/sonar-custom-plugin-example\">https://github.com/SonarSource/sonar-custom-plugin-example</a>.</p>\n<p>If you want to start the project from scratch, use the following Maven pom.xml template:</p>\n<div class=\"custom-block collapse\"><div class=\"custom-block-body\"><h2>pom.xml</h2><pre><code>&#x3C;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&#x3C;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n  &#x3C;modelVersion>4.0.0&#x3C;/modelVersion>\n  &#x3C;groupId>YOUR_GROUP_ID&#x3C;/groupId>\n  &#x3C;!-- it's recommended to follow the pattern \"sonar-{key}-plugin\", for example \"sonar-myphp-plugin\" -->\n  &#x3C;artifactId>YOUR_ARTIFACT_ID&#x3C;/artifactId>\n  &#x3C;version>YOUR_VERSION&#x3C;/version>\n  \n  &#x3C;!-- this is important for sonar-packaging-maven-plugin -->\n  &#x3C;packaging>sonar-plugin&#x3C;/packaging>\n \n  &#x3C;dependencies>\n    &#x3C;dependency>\n      &#x3C;groupId>org.sonarsource.sonarqube&#x3C;/groupId>\n      &#x3C;artifactId>sonar-plugin-api&#x3C;/artifactId>\n      &#x3C;!-- minimal version of SonarQube to support. -->\n      &#x3C;version>6.7&#x3C;/version>\n      &#x3C;!-- mandatory scope -->\n      &#x3C;scope>provided&#x3C;/scope>\n    &#x3C;/dependency>\n  &#x3C;/dependencies>\n \n  &#x3C;build>\n    &#x3C;plugins>\n      &#x3C;plugin>\n        &#x3C;groupId>org.sonarsource.sonar-packaging-maven-plugin&#x3C;/groupId>\n        &#x3C;artifactId>sonar-packaging-maven-plugin&#x3C;/artifactId>\n        &#x3C;version>1.18.0.372&#x3C;/version>\n        &#x3C;extensions>true&#x3C;/extensions>\n        &#x3C;configuration>\n          &#x3C;!-- the entry-point class that extends org.sonar.api.SonarPlugin -->\n          &#x3C;pluginClass>com.mycompany.sonar.reference.ExamplePlugin&#x3C;/pluginClass>\n           \n          &#x3C;!-- advanced properties can be set here. See paragraph \"Advanced Build Properties\". -->\n        &#x3C;/configuration>\n      &#x3C;/plugin>\n    &#x3C;/plugins>\n  &#x3C;/build>\n&#x3C;/project>\n</code></pre></div></div>\n<h3>Build</h3>\n<p>To build your plugin project, execute this command from the project root directory:<br>\n<code>mvn clean package</code><br>\nThe plugin jar file is generated in the project's <code>target/</code> directory.</p>\n<h3>Deploy</h3>\n<p><strong>\"Cold\" Deploy</strong><br>\nThe standard way to install the plugin for regular users is to copy the JAR artifact, from the <code>target/</code> directory  to the <code>extensions/plugins/</code> directory of your SonarQube installation then start the server. The file <code>logs/web.log</code> will then contain a log line similar to:<br>\n<code>Deploy plugin Example Plugin / 0.1-SNAPSHOT</code><br>\nScanner extensions such as sensors are immediately retrieved and loaded when scanning source code. </p>\n<h3>Debug</h3>\n<p><strong>Debugging web server extensions</strong>  </p>\n<ol>\n<li>Edit conf/sonar.properties and set: <code>sonar.web.javaAdditionalOpts=-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=8000</code></li>\n<li>Install your plugin by copying its JAR file to extensions/plugins</li>\n<li>Start the server. The line <code>Listening for transport dt_socket at address: 5005</code> is logged in  <code>logs/sonar.log</code>.</li>\n<li>Attach your IDE to the debug process (listening on port 8000 in the example)</li>\n</ol>\n<p><strong>Debugging compute engine extensions</strong><br>\nSame procedure as for web server extensions (see previous paragraph), but with the property: <code>sonar.ce.javaAdditionalOpts=-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=8000</code></p>\n<p><strong>Debugging scanner extensions</strong>  </p>\n<pre><code>export SONAR_SCANNER_OPTS=\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=8000\"\ncd /path/to/project\nsonar-scanner \n</code></pre>\n<p>When using the Scanner for Maven, then simply execute:</p>\n<pre><code>cd /path/to/project\nmvnDebug sonar:sonar\n# debug port is 8000\n</code></pre>\n<h3>Advanced Build Properties</h3>\n<p>Plugin properties are defined in the file <code>META-INF/MANIFEST.MF</code> of the plugin .jar file.</p>\n<p>Most of them are defined through the <code>&#x3C;configuration></code> section of the <a href=\"https://jira.sonarsource.com/browse/PACKMP\">sonar-packaging-maven-plugin</a>. Some are taken from standard pom nodes Effective values are listed at the end of the build log:</p>\n<pre><code>[INFO] --- sonar-packaging-maven-plugin:1.15:sonar-plugin (default-sonar-plugin) @ sonar-widget-lab-plugin ---\n[INFO] -------------------------------------------------------\n[INFO] Plugin definition in Marketplace\n[INFO]     Key: widgetlab\n[INFO]     Name: Widget Lab\n[INFO]     Description: Additional widgets\n[INFO]     Version: 1.9-SNAPSHOT\n[INFO]     Entry-point Class: org.codehaus.sonar.plugins.widgetlab.WidgetLabPlugin\n[INFO]     Required Plugins:\n[INFO]     Use Child-first ClassLoader: false\n[INFO]     Base Plugin:\n[INFO]     Homepage URL: https://redirect.sonarsource.com/plugins/widgetlab.html\n[INFO]     Minimal SonarQube Version: 4.5.1\n[INFO]     Licensing: GNU LGPL 3\n[INFO]     Organization: Shaw Industries\n[INFO]     Organization URL: http://shawfloors.com\n[INFO]     Terms and Conditions:\n[INFO]     Issue Tracker URL: http://jira.codehaus.org/browse/SONARWIDLB\n[INFO]     Build date: 2015-12-15T18:28:54+0100\n[INFO]     Sources URL: https://github.com/SonarCommunity/sonar-widget-lab\n[INFO]     Developers: G. Ann Campbell,Patroklos Papapetrou\n[INFO] -------------------------------------------------------\n[INFO] Building jar: /dev/sonar-widget-lab/target/sonar-widget-lab-plugin-1.9-SNAPSHOT.jar \n</code></pre>\n<p>Supported standard pom node properties:</p>\n<table>\n<thead>\n<tr>\n<th>Maven Property</th>\n<th>Manifest Key</th>\n<th>Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>version</code></td>\n<td>Plugin-Version</td>\n<td>(required) Plugin version as displayed in page \"Marketplace\". Default: ${project.version}</td>\n</tr>\n<tr>\n<td>-</td>\n<td>Sonar-Version</td>\n<td>(required) Minimal version of supported SonarQube at runtime. For example if value is 5.2, then deploying the plugin on versions 5.1 and lower will fail. Default value is given by the version of sonar-plugin-api dependency. It can be overridden with the Maven property sonarQubeMinVersion (since sonar-packaging-maven-plugin 1.16). That allows in some cases to use new features of recent API and to still be compatible at runtime with older versions of SonarQube. Default: version of dependency sonar-plugin-api</td>\n</tr>\n<tr>\n<td><code>license</code></td>\n<td>Plugin-License</td>\n<td>Plugin license as displayed in page \"Marketplace\". Default <code>${project.licenses}</code></td>\n</tr>\n<tr>\n<td><code>developers</code></td>\n<td>Plugin-Developers</td>\n<td>List of developers displayed in page \"Marketplace\". Default: <code>${project.developers}</code></td>\n</tr>\n</tbody>\n</table>\n<p>Supported <code>&#x3C;configuration></code> properties:</p>\n<table>\n<thead>\n<tr>\n<th>Maven Property</th>\n<th>Manifest Key</th>\n<th>Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>pluginKey</code></td>\n<td>Plugin-Key</td>\n<td>(required) Contains only letters/digits and is unique among all plugins. Examples: groovy, widgetlab. Constructed from <code>${project.artifactId}.</code> Given an artifactId of: <code>sonar-widget-lab-plugin</code>, your pluginKey will be: <code>widgetlab</code></td>\n</tr>\n<tr>\n<td><code>pluginClass</code></td>\n<td>Plugin-Class</td>\n<td>(required) Name of the entry-point class that extends <code>org.sonar.api.SonarPlugin</code>. Example: <code>org.codehaus.sonar.plugins.widgetlab.WidgetLabPlugin</code></td>\n</tr>\n<tr>\n<td><code>pluginName</code></td>\n<td>Plugin-Name</td>\n<td>(required) Displayed in the page \"Marketplace\". Default: <code>${project.name}</code></td>\n</tr>\n<tr>\n<td><code>pluginDescription</code></td>\n<td>Plugin-Description</td>\n<td>Displayed in the page \"Marketplace\". Default: <code>${project.description}</code></td>\n</tr>\n<tr>\n<td><code>pluginUrl</code></td>\n<td>Plugin-Homepage</td>\n<td>Homepage of website, for example <a href=\"https://github.com/SonarQubeCommunity/sonar-widget-lab\">https://github.com/SonarQubeCommunity/sonar-widget-lab</a> <code>${project.url}</code></td>\n</tr>\n<tr>\n<td><code>pluginIssueTrackerUrl</code></td>\n<td>Plugin-IssueTrackerUrl</td>\n<td>Example: <a href=\"https://github.com/SonarQubeCommunity/sonar-widget-lab/issues\">https://github.com/SonarQubeCommunity/sonar-widget-lab/issues</a>. Default: <code>${project.issueManagement.url}</code></td>\n</tr>\n<tr>\n<td><code>pluginTermsConditionsUrl</code></td>\n<td>Plugin-TermsConditionsUrl</td>\n<td>Users must read this document when installing the plugin from Marketplace. Default: <code>${sonar.pluginTermsConditionsUrl}</code></td>\n</tr>\n<tr>\n<td><code>useChildFirstClassLoader</code></td>\n<td>Plugin-ChildFirstClassLoader</td>\n<td>Each plugin is executed in an isolated classloader, which inherits a shared classloader that contains API and some other classes. By default the loading strategy of classes is parent-first (look up in shared classloader then in plugin classloader). If the property is true, then the strategy is child-first. This property is mainly used when building plugin against API &#x3C; 5.2, as the shared classloader contained many 3rd party libraries (guava 10, commons-lang, ...) false</td>\n</tr>\n<tr>\n<td><code>basePlugin</code></td>\n<td>Plugin-Base</td>\n<td>If specified, then the plugin is executed in the same classloader as basePlugin.</td>\n</tr>\n<tr>\n<td><code>pluginSourcesUrl</code></td>\n<td>Plugin-SourcesUrl</td>\n<td>URL of SCM repository for open-source plugins. Displayed in page \"Marketplace\". Default: <code>${project.scm.url}</code></td>\n</tr>\n<tr>\n<td><code>pluginOrganizationName</code></td>\n<td>Plugin-Organization</td>\n<td>Organization which develops the plugin, displayed in the page \"Marketplace\". Default: <code>${project.organization.name}</code></td>\n</tr>\n<tr>\n<td><code>pluginOrganizationUrl</code></td>\n<td>Plugin-OrganizationUrl</td>\n<td>URL of the organization, displayed in the page \"Marketplace\". Default: <code>${project.organization.url}</code></td>\n</tr>\n<tr>\n<td><code>sonarLintSupported</code></td>\n<td>SonarLint-Supported</td>\n<td>Whether the (language) plugin supports SonarLint or not. Only SonarSource analyzers (SonarJava, SonarJS, ...) and custom rules plugins for SonarSource analyzers should set this to true.</td>\n</tr>\n<tr>\n<td><code>pluginDisplayVersion</code></td>\n<td>Plugin-Display-Version</td>\n<td>The version as displayed in SonarQube administration console. By default it's the raw version, for example \"1.2\", but can be overridden to \"1.2 (build 12345)\" for instance. Supported in sonar-packaging-maven-plugin 1.18.0.372. Default: <code>${project.version}</code></td>\n</tr>\n</tbody>\n</table>\n<p>The Maven sonar-packaging-maven-plugin supports also these properties:</p>\n<table>\n<thead>\n<tr>\n<th>Maven Property</th>\n<th>Manifest Key</th>\n<th>Notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>addMavenDescriptor</code></td>\n<td>Copy pom file inside the directory META-INF of generated JAR file?</td>\n<td>Boolean. Default: <code>${sonar.addMavenDescriptor}</code> / <code>true</code>.</td>\n</tr>\n<tr>\n<td><code>skipDependenciesPackaging</code></td>\n<td>Do not copy Maven dependencies into JAR file.</td>\n<td>Default: <code>${sonar.skipDependenciesPackaging} /</code>false`.</td>\n</tr>\n</tbody>\n</table>\n<p>Other Manifest fields:  </p>\n<ul>\n<li><code>Implementation-Build</code> - Identifier of build or commit, for example the Git sha1 \"94638028f0099de59f769cdca776e506684235d6\". It is displayed for debugging purpose in logs when SonarQube server starts.</li>\n</ul>\n<h2>API basics</h2>\n<h3>Extension points</h3>\n<p>SonarQube provides extension points for its three technical stacks:</p>\n<ul>\n<li>Scanner, which runs the source code analysis</li>\n<li>\n<p>Compute Engine, which consolidates the output of scanners, for example by </p>\n<ul>\n<li>computing 2nd-level measures such as ratings</li>\n<li>aggregating measures (for example number of lines of code of project = sum of lines of code of all files)</li>\n<li>assigning new issues to developers</li>\n<li>persisting everything in data stores</li>\n</ul>\n</li>\n<li>Web application</li>\n</ul>\n<p>Extension points are not designed to add new features but to complete existing features. Technically they are contracts defined by a Java interface or an abstract class annotated with @ExtensionPoint. The exhaustive list of extension points is available in the javadoc.</p>\n<p>The implementations of extension points (named \"extensions\") provided by a plugin must be declared in its entry point class, which implements org.sonar.api.Plugin and which is referenced in pom.xml:</p>\n<p>ExamplePlugin.java</p>\n<pre><code>package org.sonarqube.plugins.example;\nimport org.sonar.api.Plugin;\n \npublic class ExamplePlugin implements Plugin {\n  @Override\n  public void define(Context context) {\n    // implementations of extension points\n    context.addExtensions(FooLanguage.class, ExampleProperties.class);\n  }\n}\n</code></pre>\n<p>pom.xml</p>\n<pre><code>&#x3C;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&#x3C;project>\n  ...\n  &#x3C;build>\n    &#x3C;plugins>\n      &#x3C;plugin>\n        &#x3C;groupId>org.sonarsource.sonar-packaging-maven-plugin&#x3C;/groupId>\n        &#x3C;artifactId>sonar-packaging-maven-plugin&#x3C;/artifactId>\n        &#x3C;extensions>true&#x3C;/extensions>\n        &#x3C;configuration>\n          &#x3C;pluginClass>org.sonarqube.plugins.example.ExamplePlugin&#x3C;/pluginClass>\n        &#x3C;/configuration>\n      &#x3C;/plugin>\n    &#x3C;/plugins>\n  &#x3C;/build>\n&#x3C;/project>\n</code></pre>\n<h3>Lifecycle</h3>\n<p>A plugin extension exists only in its associated technical stacks. A scanner sensor is for example instantiated and executed only in a scanner runtime, but not in the web server nor in Compute Engine. The stack is defined by the annotations <a href=\"http://javadocs.sonarsource.org/latest/apidocs/org/sonar/api/batch/ScannerSide.html\">@ScannerSide</a>, <a href=\"http://javadocs.sonarsource.org/latest/apidocs/index.html?org/sonar/api/server/ServerSide.html\">@ServerSide</a> (for web server) and <a href=\"http://javadocs.sonarsource.org/latest/apidocs/index.html?org/sonar/api/ce/ComputeEngineSide.html\">@ComputeEngineSide</a>. </p>\n<p>An extension can call core components or another extension of the same stack. These dependencies are defined by constructor injection:</p>\n<pre><code>@ScannerSide\npublic class Foo {\n  public void call() {}\n}\n \n// Sensor is a scanner extension point \npublic class MySensor implements Sensor {\n  private final Foo foo;\n  private final Languages languages;\n  \n  // Languages is core component which lists all the supported programming languages.\n  public MySensor(Foo foo, Languages languages) {   \n    this.foo = foo;\n    this.languages = languages;\n  }\n  \n  @Override\n  public void execute(SensorContext context) {\n    System.out.println(this.languages.all());\n    foo.call();\n  }\n}\n \n  \npublic class ExamplePlugin implements Plugin {\n  @Override\n  public void define(Context context) {\n    // Languages is a core component. It must not be declared by plugins.\n    context.addExtensions(Foo.class, MySensor.class);\n  }\n}\n</code></pre>\n<p>It is recommended not to call other components in constructors. Indeed, they may not be initialized at that time. Constructors should only be used for dependency injection.</p>\n<div class=\"custom-block alert alert-warning\"><div class=\"custom-block-body\"><p>Compilation does not fail if incorrect dependencies are defined, such as a scanner extension trying to call a web server extension. Still it will fail at runtime when plugin is loaded.</p></div></div>\n<h3>Third-party Libraries</h3>\n<p>Plugins are executed in their own isolated classloaders. That allows the packaging and use of 3rd-party libraries without runtime conflicts with core internal libraries or other plugins. Note that since version 5.2, the SonarQube API does not bring transitive dependencies, except SLF4J. The libraries just have to be declared in the pom.xml with default scope \"compile\":</p>\n<p>pom.xml</p>\n<pre><code>&#x3C;?xml version=\"1.0\" encoding=\"UTF-8\"?>\n&#x3C;project>\n  ...\n  &#x3C;dependencies>\n    ...\n    &#x3C;dependency>\n      &#x3C;groupId>commons-codec&#x3C;/groupId>\n      &#x3C;artifactId>commons-codec&#x3C;/artifactId>\n      &#x3C;version>1.10&#x3C;/version>\n    &#x3C;/dependency>\n &#x3C;/dependencies>\n&#x3C;/project>\n</code></pre>\n<p>Technically the libraries are packaged in the directory META-INF/lib of the generated JAR file. An alternative is to shade libraries, for example with maven-shade-plugin. That minimizes the size of the plugin .jar file by copying only the effective used classes.</p>\n<div class=\"custom-block alert alert-info\"><div class=\"custom-block-body\"><p>The command <code>mvn dependency:tree</code> gives the list of all dependencies, including transitive ones.</p></div></div>\n<h3>Configuration</h3>\n<p>The core component <a href=\"http://javadocs.sonarsource.org/latest/apidocs/index.html?org/sonar/api/config/Configuration.html\"><code>org.sonar.api.config.Configuration</code></a> provides access to configuration. It deals with default values and decryption of values. It is available in all stacks (scanner, web server, Compute Engine). As recommended earlier, it must not be called from constructors.</p>\n<p>MyExtension.java</p>\n<pre><code>public class MyRules implements RulesDefinition {\n  private final Configuration config;\n  \n  public MyRules(Configuration config) {   \n    this.config = config; \n  }\n  \n  @Override\n  public void define(Context context) {\n    int value = config.getInt(\"sonar.property\").orElse(0);\n  }\n}\n</code></pre>\n<p>Scanner sensors can get config directly from SensorContext, without using constructor injection:</p>\n<p>MySensor.java</p>\n<pre><code>public class MySensor extends Sensor {\n  @Override\n  public void execute(SensorContext context) {\n    int value = context.config().getInt(\"sonar.property\").orElse(0);\n  }\n}\n</code></pre>\n<p>In the scanner stack, properties are checked in the following order, and the first non-blank value is the one that is used:</p>\n<ol>\n<li>System property</li>\n<li>Scanner command-line (-Dsonar.property=foo for instance)</li>\n<li>Scanner tool (<properties> of scanner for Maven for instance) </li>\n<li>Project configuration defined in the web UI </li>\n<li>Global configuration defined in the web UI </li>\n<li>Default value</li>\n</ol>\n<p>Plugins can define their own properties so that they can be configured from web administration console. The extension point org.sonar.api.config.PropertyDefinition must be used :</p>\n<pre><code>public class ExamplePlugin implements Plugin {\n  @Override\n  public void define(Context context) {\n    context.addExtension(\n      PropertyDefinition.builder(\"sonar.my.property\")\n       .name(\"My Property\")\n       .description(\"This is the description displayed in web admin console\")\n       .defaultValue(\"42\")\n       .build()\n    );\n  }\n}\n</code></pre>\n<div class=\"custom-block alert alert-info\"><div class=\"custom-block-body\"><p>Values of the properties suffixed with <code>.secured</code> are not available to non-authorized users (anonymous and users without project or global administration rights). <code>.secured</code> is needed for passwords, for instance.</p></div></div>\n<p>The annotation <a href=\"http://javadocs.sonarsource.org/latest/apidocs/index.html?org/sonar/api/Property.html\"><code>@org.sonar.api.Property</code></a> can also be used on an extension to declare a property, but org.sonar.api.config.PropertyDefinition is preferred.</p>\n<pre><code>@Properties(\n    @Property(key=\"sonar.my.property\", name=\"My Property\", defaultValue=\"42\")\n)\npublic class MySensor implements Sensor {\n  // ...\n}\n  \npublic class ExamplePlugin implements Plugin {\n  @Override\n  public void define(Context context) {\n    context.addExtension(MySensor.class);\n  }\n}\n</code></pre>\n<h3>Logging</h3>\n<p>The class <a href=\"http://javadocs.sonarsource.org/latest/apidocs/index.html?org/sonar/api/utils/log/Logger.html\"><code>org.sonar.api.utils.log.Logger</code></a> is used to log messages to scanner output, web server logs/sonar.log, or Compute Engine logs (available from administration web console). It's convenient for unit testing (see class <a href=\"http://javadocs.sonarsource.org/latest/apidocs/index.html?org/sonar/api/utils/log/LogTester.html\"><code>LogTester</code></a>).</p>\n<pre><code>import org.sonar.api.utils.log.*;\npublic class MyClass {\n  private static final Logger LOGGER = Loggers.get(MyClass.class);\n \n  public void doSomething() {\n    LOGGER.info(\"foo\");\n  }\n}\n</code></pre>\n<p>Internally <a href=\"http://www.slf4j.org/\">SLF4J</a> is used as a facade of various logging frameworks (log4j, commons-log, logback, java.util.logging). That allows all these frameworks to work at runtime, such as when they are required for a 3rd party library. SLF4J loggers can also be used instead of org.sonar.api.utils.log.Logger. Read the <a href=\"http://www.slf4j.org/manual.html\">SLF4J manual</a> for more details.</p>\n<p>As an exception, plugins must not package logging libraries. Dependencies like SLF4J or log4j must be declared with scope \"provided\".</p>\n<h3>Exposing APIs to Other Plugins</h3>\n<p>The common use case is to write a language plugin that will allow some other plugins to contribute additional rules (see for example how it is done in SonarJava). The main plugin will expose some APIs that will be implemented/used by the \"rule\" plugins.</p>\n<p>Plugins are loaded in isolated classloaders. It means a plugin can't access another plugin's classes. There is an exception for package names following pattern <code>org.sonar.plugins.&#x3C;pluginKey>.api</code>. For example all classes in a plugin with the key myplugin that are located in <code>org.sonar.plugins.myplugin.api</code> are visible to other plugins.</p>\n<h3>Serving Static Resources</h3>\n<p>If you need to serve static resources from your plugin such as images or JavaScript files, place them in a directory under <code>resources</code> named <code>static</code> (<code>myplugin/src/main/resources/static</code>). At runtime they'll be available from <code>http://{server}/static/{pluginKey}/{file}</code>. </p>\n<h2>Versioning and API Deprecation</h2>\n<h3>Versioning Strategy</h3>\n<p>The goal of this versioning strategy is both to:</p>\n<ul>\n<li>Release often, release early in order to get quick feedback from the SonarQube community</li>\n<li>Release stable versions of the SonarQube platform for companies whose main priority is to set up a very stable environment. Even if the price for such stable environments is missing out on the latest, sexy SonarQube features</li>\n<li>Support the API deprecation strategy (see next section)</li>\n</ul>\n<p>The rules are:</p>\n<ul>\n<li>Each ~two months a new version of SonarQube is released. This version should increment the minor digit of the previous version (ex: 4.2 -> 4.3)</li>\n<li>After three (or more) releases, a bug-fix version is released, and becomes the new LTS. The major digit of the subsequent version is incremented to start a new cycle (ex: 5.6 -> 6.0)</li>\n</ul>\n<p>And here is the strategy in action:</p>\n<pre><code>4.4 -> 4.5 -> 5.0 -> 5.1 -> 5.2 -> ... -> 5.5 -> 6.0 -> ...     &#x3C;- New release every ~2 months\n        |                                  |\n      4.5.1 -> 4.5.2 -> ...              5.5.1 -> 5.5.2 -> ...  &#x3C;- New LTS\n</code></pre>\n<h3>API Deprecation Strategy</h3>\n<p>The goal of this deprecation strategy is to make sure that deprecated APIs will be dropped without side-effects at a given planned date. The expected consequence of such strategy is to ease the evolution of the SonarQube API by making such refactoring painless.</p>\n<p>The rules are:</p>\n<ul>\n<li>An API must be deprecated before being dropped</li>\n<li>A deprecated API must be fully supported until its drop (For instance the implementation of a deprecated method can't be replaced by <code>throw new UnsupportedOperationException())</code></li>\n<li>If an API is deprecated in version X.Y, this API will be dropped in version (X+2).0. Example: an API deprecated in 4.1 is supported in 4.2, 4.3, 5.0, 5.1, 5.2, 5.3 and is dropped in version 6.0.</li>\n<li>According to the versioning strategy, that means that an API can remain deprecated before being dropped during 6 to 12 months.</li>\n<li>Any release of a SonarQube plugin must at least depend on the latest LTS version of the SonarQube API</li>\n<li>For each SonarQube plugin there must at least one release on each LTS version of SonarQube, which means at least one release each 6 months.</li>\n<li>No use of deprecated APIs is accepted when releasing a plugin. It raises a critical issue in SonarQube analysis. This issue can't be postponed.</li>\n<li>No deprecated API introduced 2 major versions ago is accepted when releasing SonarQube. It raises a critical issue in SonarQube analysis. This issue can't be postponed.</li>\n<li>\n<p>An API is marked as deprecated with both:</p>\n<ul>\n<li>the annotation @Deprecated</li>\n<li>\n<p>the javadoc tag @deprecated whose message must start with \"in x.y\", for example:</p>\n<pre><code>/**\n</code></pre>\n</li>\n<li>\n<p>@deprecated in 4.2. Replaced by {@link #newMethod()}.\n*/\n@Deprecated\npublic void foo() {</p>\n<pre><code></code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2>API Changes</h2>\n<h3>Release 7.9</h3>\n<p>No changes</p>\n<h3>Release 7.8</h3>\n<p><img src=\"/images/check.svg\"> Added</p>\n<ul>\n<li><code>org.sonar.api.web.WebAnalytics</code></li>\n</ul>\n<p><img src=\"/images/exclamation.svg\"> Deprecated</p>\n<ul>\n<li><code>org.sonar.api.i18n.I18</code></li>\n<li><code>org.sonar.api.SonarQubeVersion</code> use <code>org.sonar.api.SonarRuntime</code> instead</li>\n<li><code>org.sonar.api.profiles.XMLProfileParser</code></li>\n<li><code>org.sonar.api.notifications.NotificationChannel</code></li>\n</ul>\n<p><img src=\"/images/cross.svg\"> Removed</p>\n<ul>\n<li>Pico components relying on reflection to have their <code>start</code> or <code>stop</code> method called. Make your component implements <code>org.sonar.api.Startable</code> instead.</li>\n</ul>\n<h3>Release 7.7</h3>\n<p><img src=\"/images/check.svg\"> Added</p>\n<ul>\n<li><code>org.sonar.api.batch.scm.ScmProvider#ignoreCommand</code></li>\n</ul>\n<p><img src=\"/images/exclamation.svg\"> Deprecated</p>\n<ul>\n<li><code>org.sonar.api.batch.fs.InputFile::status</code></li>\n<li><code>org.sonar.api.resources.Qualifiers#BRC</code></li>\n</ul>\n<p><img src=\"/images/cross.svg\"> Removed</p>\n<ul>\n<li>The preview/issues mode of scanner has been removed</li>\n</ul>\n<h3>Release 7.6</h3>\n<p><img src=\"/images/info.svg\"> Changed</p>\n<ul>\n<li><code>PostJob</code> moved to project level IoC container</li>\n<li><code>InputFileFilter</code> moved to project level IoC container</li>\n</ul>\n<p><img src=\"/images/check.svg\"> Added</p>\n<ul>\n<li>New annotation <code>org.sonar.api.scanner.ScannerSide</code> to mark (project level) scanner components</li>\n<li><code>org.sonar.api.batch.fs.InputProject</code> to create issues on project</li>\n<li><code>org.sonar.api.scanner.ProjectSensor</code> to declare Sensors that only run at project level</li>\n</ul>\n<p><img src=\"/images/exclamation.svg\"> Deprecated</p>\n<ul>\n<li><code>org.sonar.scanner.issue.IssueFilter</code> deprecated</li>\n<li><code>org.sonar.api.batch.InstantiationStrategy</code> deprecated</li>\n<li><code>org.sonar.api.batch.ScannerSide</code> deprecated</li>\n<li><code>org.sonar.api.batch.fs.InputModule</code> deprecated</li>\n<li>Concept of global Sensor is deprecated (use <code>ProjectSensor</code> instead)</li>\n</ul>\n<p><img src=\"/images/cross.svg\"> Removed</p>\n<ul>\n<li>Support of scanner tasks was removed</li>\n<li><code>RulesProfile</code> is no longer available for scanner side components (use <code>ActiveRules</code> instead)</li>\n</ul>\n<h3>Release 7.5</h3>\n<p>No changes</p>\n<h3>Release 7.4</h3>\n<p><img src=\"/images/info.svg\"> Changed</p>\n<ul>\n<li>Allow identity provider to not provide login</li>\n</ul>\n<p><img src=\"/images/check.svg\"> Added</p>\n<ul>\n<li>Allow sensors to report adhoc rules metadata</li>\n</ul>\n<p><img src=\"/images/cross.svg\"> Removed</p>\n<ul>\n<li><code>org.sonar.api.rules.RuleFinder</code> removed from scanner side</li>\n<li><code>sonar-channel</code> removed from plugin classloader</li>\n<li>stop support of plugins compiled with API &#x3C; 5.2</li>\n</ul>\n<h3>Release 7.3</h3>\n<p><img src=\"/images/check.svg\"> Added</p>\n<ul>\n<li><code>RulesDefinitions</code> supports HotSpots and security standards</li>\n</ul>\n<p><img src=\"/images/exclamation.svg\"> Deprecated</p>\n<ul>\n<li><code>org.sonar.api.batch.AnalysisMode</code> and <code>org.sonar.api.issue.ProjectIssues</code> since preview mode is already deprecated for a while</li>\n</ul>\n<h3>Release 7.2</h3>\n<p><img src=\"/images/check.svg\"> Added</p>\n<ul>\n<li><code>org.sonar.api.batch.sensor.SensorContext#newExternalIssue</code> to report external issues</li>\n<li><code>org.sonar.api.batch.sensor.SensorContext#newSignificantCode</code> to report part of the source file that should be used for issue tracking</li>\n<li><code>org.sonar.api.scan.issue.filter.FilterableIssue#textRange</code></li>\n</ul>\n<p><img src=\"/images/exclamation.svg\"> Deprecated</p>\n<ul>\n<li>org.sonar.api.scan.issue.filter.FilterableIssue#line</li>\n</ul>\n<h3>Release 7.1</h3>\n<p><img src=\"/images/check.svg\"> Added</p>\n<ul>\n<li><code>org.sonar.api.Plugin.Context#getBootConfiguration</code></li>\n<li><code>org.sonar.api.server.rule.RulesDefinition.NewRule#addDeprecatedRuleKey</code> to support deprecated rule keys</li>\n</ul>\n<h3>Release 7.0</h3>\n<p><img src=\"/images/check.svg\"> Added</p>\n<ul>\n<li><code>org.sonar.api.batch.scm.ScmProvider#relativePathFromScmRoot</code>, <code>org.sonar.api.batch.scm.ScmProvider#branchChangedFiles</code> and <code>org.sonar.api.batch.scm.ScmProvider#revisionId</code> to improve branch and PR support</li>\n</ul>\n<h3>Release 6.7</h3>\n<p>No changes</p>"}