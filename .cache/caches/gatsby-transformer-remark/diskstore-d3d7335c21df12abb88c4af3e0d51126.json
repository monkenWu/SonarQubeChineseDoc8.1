{"expireTime":9007200835323870000,"key":"transformer-remark-markdown-html-ba6d6a402830a6d1ebfc0b6c2f4eb65d-gatsby-remark-custom-blocks-/SonarQubeChineseDoc8.1","val":"<!-- update_center:java -->\n<h2>Language-Specific Properties</h2>\n<p>You can discover and update the Java-specific <a href=\"/SonarQubeChineseDoc8.1/analysis/analysis-parameters/\">properties</a> in:  <a href=\"/SonarQubeChineseDoc8.1/#sonarqube-admin#/admin/settings?category=java\">Administration > General Settings > Java</a></p>\n<h2>Java Analysis and Bytecode</h2>\n<p>Compiled <code>.class</code> files are required for java projects with more than one java file. If not provided properly, analysis will fail with the message:</p>\n<pre><code>Please provide compiled classes of your project with sonar.java.binaries property.\n</code></pre>\n<p>If only some <code>.class</code> files are missing, you'll see warnings like this:</p>\n<pre><code>Class 'XXXXXX' is not accessible through the ClassLoader.\n</code></pre>\n<p>If you are not using Maven or Gradle for analysis, you must manually provide bytecode to the analysis.\nYou can also analyze test code, and for that you need to provide tests binaires and test libraries properties.</p>\n<table>\n<thead>\n<tr>\n<th>Key</th>\n<th>Value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>sonar.java.binaries</code> (required)</td>\n<td>Comma-separated paths to directories containing the compiled bytecode files corresponding to your source files.</td>\n</tr>\n<tr>\n<td><code>sonar.java.libraries</code></td>\n<td>Comma-separated paths to files with third-party libraries (JAR or Zip files) used by your project. Wildcards can be used: <code>sonar.java.libraries=path/to/Library.jar,directory/**/*.jar</code></td>\n</tr>\n<tr>\n<td><code>sonar.java.test.binaries</code></td>\n<td>Comma-separated paths to directories containing the compiled bytecode files corresponding to your test files</td>\n</tr>\n<tr>\n<td><code>sonar.java.test.libraries</code></td>\n<td>Comma-separated paths to files with third-party libraries (JAR or Zip files) used by your tests. (For example, this should include the junit jar). Wildcards can be used: <code>sonar.java.test.libraries=directory/**/*.jar</code></td>\n</tr>\n</tbody>\n</table>\n<div class=\"custom-block alert alert-warning\"><div class=\"custom-block-body\"><p>Android users, Jack doesn't provide the required <code>.class</code> files.</p></div></div>\n<h2>Turning issues off</h2>\n<p>The best way to deactivate an individual issue you don't intend to fix is to mark it \"Won't Fix\" or \"False Positive\" through the SonarQube UI.</p>\n<p>If you need to deactivate a rule (or all rules) for an entire file, then <a href=\"/SonarQubeChineseDoc8.1/project-administration/narrowing-the-focus/\">issue exclusions</a> are the way to go. But if you only want to deactivate a rule across a subset of a file - all the lines of a method or a class - you can use <code>@SuppressWarnings(\"all\")</code> or <code>@SuppressWarnings</code> with rule keys: <code>@SuppressWarnings(\"squid:S2078\")</code> or <code>@SuppressWarnings({\"squid:S2078\", \"squid:S2076\"})</code>. </p>\n<h2>Handling Java Source Version</h2>\n<p>The Java Analyzer is able to react to the java version used for sources. This feature allows the deactivation of rules that target higher versions of Java than the one in use in the project so that false positives aren't generated from irrelevant rules.</p>\n<p>The feature relies entirely on the <code>sonar.java.source</code> property, which is automatically filled by most of the scanners used for analyses (Maven, Gradle). Java version-specific rules are not disabled when <code>sonar.java.source</code> is not provided. Concretely, rules which are designed to target specific java versions (tagged \"java7\" or \"java8\") are activated by default in the Sonar Way Java profile. From a user perspective, the feature is fully automatic, but it means that you probably want your projects to be correctly configured.</p>\n<p>When using SonarScanner to perform analyses of project, the property <code>sonar.java.source</code> can to be set manually in <code>sonar-project.properties</code>. Accepted formats are:</p>\n<ul>\n<li>\"1.X\" (for instance 1.6 for java 6, 1.7 for java 7, 1.8 for java 8, etc.)</li>\n<li>\"X\" (for instance 7 for java 7, 8 for java 8, etc. )</li>\n</ul>\n<p>Example: <code>sonar.java.source=1.6</code></p>\n<p>If the property is provided, the analysis will take the source version into account, and execute related rules accordingly. At run time, each of these rules will be executed – or not – depending of the Java version used by sources within the project. For instance, on a correctly configured project built with Java 6, rules targeting Java 7 and Java 8 will never raise issues, even though they are enabled in the associated rule profile.</p>\n<h2>Custom Rules</h2>\n<p>The tutorial <a href=\"https://redirect.sonarsource.com/doc/java-custom-rules-guide.html\">Writing Custom Java Rules 101</a> will help to quickly start writing custom rules for Java.</p>\n<h3>API changes</h3>\n<h4><strong>5.12</strong></h4>\n<ul>\n<li>\n<p><strong>Dropped</strong></p>\n<ul>\n<li>\n<p><code>org.sonar.plugins.java.api.JavaFileScannerContext</code>: Drop deprecated method used to retrieve trees contributing to the complexity of a method from  (deprecated since SonarJava 4.1). </p>\n<pre><code>//org.sonar.plugins.java.api.JavaFileScannerContext\n/**\n* Computes the list of syntax nodes which are contributing to increase the complexity for the given methodTree.\n* @deprecated use {@link #getComplexityNodes(Tree)} instead\n* @param enclosingClass not used.\n* @param methodTree the methodTree to compute the complexity.\n* @return the list of syntax nodes incrementing the complexity.\n*/\n@Deprecated\nList&#x3C;Tree> getMethodComplexityNodes(ClassTree enclosingClass, MethodTree methodTree);\n</code></pre>\n</li>\n<li>\n<p><code>org.sonar.plugins.java.api.JavaResourceLocator</code>: The following method has been dropped (deprecated since SonarJava 4.1), without replacement.</p>\n<pre><code>//org.sonar.plugins.java.api.JavaResourceLocator\n/**\n* get source file key by class name.\n* @deprecated since 4.1 : will be dropped with no replacement.\n* @param className fully qualified name of the analyzed class.\n* @return key of the source file for the given class.\n*/\n@Deprecated\nString findSourceFileKeyByClassName(String className);\n</code></pre>\n</li>\n<li>\n<p><code>org.sonar.plugins.surefire.api.SurefireUtils</code>: Dropping deprecated field with old property (deprecated since SonarJava 4.11)</p>\n<pre><code>//org.sonar.plugins.surefire.api.SurefireUtils\n/**\n* @deprecated since 4.11\n*/\n@Deprecated\npublic static final String SUREFIRE_REPORTS_PATH_PROPERTY = \"sonar.junit.reportsPath\";\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Deprecated</strong>  </p>\n<ul>\n<li>\n<p><code>org.sonar.plugins.java.api.JavaFileScannerContext</code>: Deprecate usage of File-based methods from API, which will be removed in future release. Starting from this version, methods relying on InputFile has to be preferred.</p>\n<pre><code>//org.sonar.plugins.java.api.JavaFileScannerContext\n/**\n* Report an issue at a specific line of a given file.\n* This method is used for one\n* @param file File on which to report\n* @param check The check raising the issue.\n* @param line line on which to report the issue\n* @param message Message to display to the user\n* @deprecated since SonarJava 5.12 - File are not supported anymore. Use corresponding 'reportIssue' methods, or directly at project level\n*/\n@Deprecated\nvoid addIssue(File file, JavaCheck check, int line, String message);\n/**\n* FileKey of currently analyzed file.\n* @return the fileKey of the file currently analyzed.\n* @deprecated since SonarJava 5.12 - Rely on the InputFile key instead, using {@link #getInputFile()}\n*/\n@Deprecated\nString getFileKey();\n\n/**\n* File under analysis.\n* @return the currently analyzed file.\n* @deprecated since SonarJava 5.12 - File are not supported anymore. Use {@link #getInputFile()} or {@link #getProject()} instead\n*/\n@Deprecated\nFile getFile();\n</code></pre>\n</li>\n<li>\n<p>Deprecate methods which are not relevant anymore in switch-related trees from API, following introduction of the new Java 12 <code>switch</code> expression:</p>\n<pre><code>//org.sonar.plugins.java.api.tree.CaseLabelTree\n/**\n* @deprecated (since 5.12) use the {@link #expressions()} method.\n*/\n@Deprecated\n@Nullable\nExpressionTree expression();\n\n/**\n* @deprecated (since 5.12) use the {@link #colonOrArrowToken()} method.\n*/\n@Deprecated\nSyntaxToken colonToken();\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>Added</strong></p>\n<ul>\n<li>\n<p><code>org.sonar.plugins.java.api.JavaFileScannerContext</code>: Following methods have been added in order to provide help reporting issues at project level, and access data through SonarQube's InputFile API, which won't be possible anymore through files:</p>\n<pre><code>//JavaFileScannerContext: New methods\n/**\n* Report an issue at at the project level.\n* @param check The check raising the issue.\n* @param message Message to display to the user\n*/\nvoid addIssueOnProject(JavaCheck check, String message);\n\n/**\n* InputFile under analysis.\n* @return the currently analyzed inputFile.\n*/\nInputFile getInputFile();\n\n/**\n* InputComponent representing the project being analyzed\n* @return the project component\n*/\nInputComponent getProject();\n</code></pre>\n</li>\n<li>\n<p>In order to cover the Java 12 new switch expression, introduce a new Tree in the SonarJava Syntax Tree API  (Corresponding <code>Tree.Kind</code>: <code>SWITCH_EXPRESSION</code> ). New methods have also been added to fluently integrate the new switch expression into the SonarJava API.</p>\n<pre><code>//org.sonar.plugins.java.api.tree.SwitchExpressionTree\n/**\n* 'switch' expression.\n*\n* JLS 14.11\n*\n* &#x3C;pre>\n*   switch ( {@link #expression()} ) {\n*     {@link #cases()}\n*   }\n* &#x3C;/pre>\n*\n* @since Java 12\n*/\n@Beta\npublic interface SwitchExpressionTree extends ExpressionTree {\n\nSyntaxToken switchKeyword();\n\nSyntaxToken openParenToken();\n\nExpressionTree expression();\n\nSyntaxToken closeParenToken();\n\nSyntaxToken openBraceToken();\n\nList&#x3C;CaseGroupTree> cases();\n\nSyntaxToken closeBraceToken();\n}\n</code></pre>\n<pre><code>//org.sonar.plugins.java.api.tree.SwitchStatementTree\n/**\n* Switch expressions introduced with support Java 12\n* @since SonarJava 5.12\n*/\nSwitchExpressionTree asSwitchExpression();\n</code></pre>\n<pre><code>//org.sonar.plugins.java.api.tree.CaseLabelTree\n/**\n* @return true for case with colon: \"case 3:\" or \"default:\"\n*         false for case with arrow: \"case 3 ->\" or \"default ->\"\n* @since 5.12 (Java 12 new features)\n*/\nboolean isFallThrough();\n\n/**\n* @since 5.12 (Java 12 new features)\n*/\nSyntaxToken colonOrArrowToken();\n</code></pre>\n<pre><code>//org.sonar.plugins.java.api.tree.BreakStatementTree\n/**\n* @since 5.12 (Java 12 new features)\n*/\n@Nullable\nExpressionTree value();\n</code></pre>\n<pre><code>//org.sonar.plugins.java.api.tree.TreeVisitor\nvoid visitSwitchExpression(SwitchExpressionTree tree);\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h4><strong>5.7</strong></h4>\n<ul>\n<li>\n<p><strong>Breaking</strong>  </p>\n<ul>\n<li>This change will impact mostly the custom rules relying on semantic API. The type returned by some symbols will change from raw type to parameterized type with identity substitution and this will change how subtyping will answer.</li>\n</ul>\n<p>It is possible to get the previous behavior back by using type erasure on the newly returned type. Note that not all returned types are impacted by this change.</p>\n<p>Example:</p>\n<pre><code>@Rule(key = \"MyFirstCustomRule\")\npublic class MyFirstCustomCheck extends IssuableSubscriptionVisitor {\n\n    @Override\n    public List&#x3C;Kind> nodesToVisit() {\n        return ImmutableList.of(Kind.METHOD);\n    }\n\n    @Override\n    public void visitNode(Tree tree) {\n        MethodTree method = (MethodTree) tree;\n        MethodSymbol symbol = method.symbol();\n        \n        Type returnType = symbol.returnType().type();\n        // When analyzing the code \"MyClass&#x3C;Integer> foo() {return null; }\"\n        // BEFORE: returnType == ClassJavaType\n        // NOW: returnType == ParametrizedTypeJavaType\n\n        // Getting back previous type\n        Type erasedType = returnType.erasure();\n        // erasedType == ClassJavaType\n    }\n}\n</code></pre>\n</li>\n</ul>\n<h2>Related Pages</h2>\n<ul>\n<li><a href=\"/SonarQubeChineseDoc8.1/analysis/coverage/\">Test Coverage &#x26; Execution</a> (<a href=\"https://spotbugs.github.io/\">SpotBugs</a>, FindBugs, <a href=\"https://github.com/find-sec-bugs/find-sec-bugs/wiki/Maven-configuration\">FindSecBugs</a>, <a href=\"http://maven.apache.org/plugins/maven-pmd-plugin/usage.html\">PMD</a>, <a href=\"http://maven.apache.org/plugins/maven-checkstyle-plugin/checkstyle-mojo\">Checkstyle</a>)</li>\n<li><a href=\"/SonarQubeChineseDoc8.1/analysis/external-issues/\">Importing External Issues</a> (JaCoCo, Surefire)</li>\n<li><a href=\"/SonarQubeChineseDoc8.1/extend/adding-coding-rules/\">Adding Coding Rules</a></li>\n</ul>"}