{"expireTime":9007200870884089000,"key":"transformer-remark-markdown-html-d67ac63e5f2f125c9eb4586c87edb6c3-gatsby-remark-custom-blocks-/SonarQubeChineseDoc8.1","val":"<div class=\"custom-block alert alert-info\"><div class=\"custom-block-body\"><p>By <a href=\"https://www.sonarsource.com/\">SonarSource</a> – GNU LGPL 3 – <a href=\"https://jira.sonarsource.com/browse/SONARGRADL\">Issue Tracker</a> – <a href=\"https://github.com/SonarSource/sonar-scanner-gradle\">Source</a><br>\nClick <a href=\"https://plugins.gradle.org/plugin/org.sonarqube\">here</a> for the latest version.</p></div></div>\n<p>The SonarScanner for Gradle provides an easy way to start SonarQube analysis of a Gradle project.</p>\n<p>The ability to execute the SonarQube analysis via a regular Gradle task makes it available anywhere Gradle is available (developer build, CI server, etc.), without the need to manually download, setup, and maintain a SonarQube Runner installation. The Gradle build already has much of the information needed for SonarQube to successfully analyze a project. By preconfiguring the analysis based on that information, the need for manual configuration is reduced significantly. </p>\n<h2>Prerequisites</h2>\n<ul>\n<li>Gradle versions 2.14+</li>\n<li>At least the minimal version of Java supported by your SonarQube server is in use </li>\n</ul>\n<p>Bytecode created by javac compilation is required for Java analysis, including Android projects.</p>\n<h2>Configure the Scanner</h2>\n<p>Installation is automatic, but certain global properties should still be configured. A good place to configure global properties is <code>~/.gradle/gradle.properties</code>. Be aware that the scanner uses system properties so all properties should be prefixed by <code>systemProp</code>.</p>\n<pre><code># gradle.properties\nsystemProp.sonar.host.url=http://localhost:9000\n \n#----- Token generated from an account with 'publish analysis' permission\nsystemProp.sonar.login=&#x3C;token>\n</code></pre>\n<h2>Analyzing</h2>\n<p>First, activate the scanner in your build. For Gradle 2.1+, in <code>build.gradle</code>:</p>\n<pre><code>plugins {\n  id \"org.sonarqube\" version \"2.7\"\n}\n</code></pre>\n<p>More details on <a href=\"https://plugins.gradle.org/plugin/org.sonarqube\">https://plugins.gradle.org/plugin/org.sonarqube</a></p>\n<p>Assuming a local SonarQube server with out-of-the-box settings is up and running, no further configuration is required.</p>\n<p>Execute <code>gradle sonarqube</code> and wait until the build has completed, then open the web page indicated at the bottom of the console output. You should now be able to browse the analysis results.</p>\n<h2>Analyzing Multi-Project Builds</h2>\n<p>To analyze a project hierarchy, apply the SonarQube plugin to the root project of the hierarchy. Typically (but not necessarily) this will be the root project of the Gradle build. Information pertaining to the analysis as a whole has to be configured in the sonarqube block of this project. Any properties set on the command line also apply to this project.</p>\n<pre><code>// build.gradle\nsonarqube {\n    properties {\n        property \"sonar.sourceEncoding\", \"UTF-8\"\n    }\n}\n</code></pre>\n<p>Configuration shared between subprojects can be configured in a subprojects block.</p>\n<pre><code>// build.gradle\nsubprojects {\n    sonarqube {\n        properties {\n            property \"sonar.sources\", \"src\"\n        }\n    }\n}\n</code></pre>\n<p>Project-specific information is configured in the <code>sonarqube</code> block of the corresponding project.</p>\n<pre><code>// build.gradle\nproject(\":project1\") {\n    sonarqube {\n        properties {\n            property \"sonar.branch\", \"Foo\"\n        }\n    }}\n</code></pre>\n<p>To skip SonarQube analysis for a particular subproject, set sonarqube.skipProject to true.</p>\n<pre><code>// build.gradle\nproject(\":project2\") {\n    sonarqube {\n        skipProject = true\n    }\n}\n</code></pre>\n<h2>Task dependencies</h2>\n<p>All tasks that produce output that should be included in the SonarQube analysis need to be executed before the <code>sonarqube</code> task runs. Typically, these are compile tasks, test tasks, and code coverage tasks. To meet these needs, the plugins adds a task dependency from <code>sonarqube</code> on <code>test</code> if the Java plugin is applied. Further task dependencies can be added as needed. For example:</p>\n<pre><code>// build.gradle\nproject.tasks[\"sonarqube\"].dependsOn \"anotherTask\"\n</code></pre>\n<h2>Sample project</h2>\n<p>A simple working example is available at this URL so you can check everything is correctly configured in your env:<br>\n<a href=\"https://github.com/SonarSource/sonar-scanning-examples/tree/master/sonarqube-scanner-gradle\">https://github.com/SonarSource/sonar-scanning-examples/tree/master/sonarqube-scanner-gradle</a></p>\n<h2>Analysis property defaults</h2>\n<p>The SonarScanner for Gradle uses information contained in Gradle's object model to provide smart defaults for most of the standard <a href=\"/SonarQubeChineseDoc8.1/analysis/analysis-parameters/\">analysis parameters</a>, as listed below.</p>\n<p>Gradle defaults for standard SonarQube properties: </p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Gradle default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>sonar.projectKey</code></td>\n<td><code>[${project.group}:]${project.name}</code> for root module; <code>&#x3C;root module key>:&#x3C;module path></code> for submodules</td>\n</tr>\n<tr>\n<td><code>sonar.projectName</code></td>\n<td><code>${project.name}</code></td>\n</tr>\n<tr>\n<td><code>sonar.projectDescription</code></td>\n<td><code>${project.description}</code></td>\n</tr>\n<tr>\n<td><code>sonar.projectVersion</code></td>\n<td><code>${project.version}</code></td>\n</tr>\n<tr>\n<td><code>sonar.projectBaseDir</code></td>\n<td><code>${project.projectDir}</code></td>\n</tr>\n<tr>\n<td><code>sonar.working.directory</code></td>\n<td><code>${project.buildDir}/sonar</code></td>\n</tr>\n</tbody>\n</table>\n<p>Notice that additional defaults are provided for projects that have the java-base or java plugin applied:</p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Gradle default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>sonar.sourceEncoding</code></td>\n<td><code>${project.compileJava.options.encoding}</code></td>\n</tr>\n<tr>\n<td><code>sonar.java.source</code></td>\n<td><code>${project.sourceCompatibility}</code></td>\n</tr>\n<tr>\n<td><code>sonar.java.target</code></td>\n<td><code>${project.targetCompatibility}</code></td>\n</tr>\n<tr>\n<td><code>sonar.sources</code></td>\n<td><code>${sourceSets.main.allSource.srcDirs}</code> (filtered to only include existing directories)</td>\n</tr>\n<tr>\n<td><code>sonar.tests</code></td>\n<td><code>${sourceSets.test.allSource.srcDirs}</code> (filtered to only include existing directories)</td>\n</tr>\n<tr>\n<td><code>sonar.java.binaries</code></td>\n<td><code>${sourceSets.main.output.classesDir}</code></td>\n</tr>\n<tr>\n<td><code>sonar.java.libraries</code></td>\n<td><code>${sourceSets.main.compileClasspath}</code> (filtering to only include files; rt.jar and jfxrt.jar added if necessary)</td>\n</tr>\n<tr>\n<td><code>sonar.java.test.binaries</code></td>\n<td><code>${sourceSets.test.output.classesDir}</code></td>\n</tr>\n<tr>\n<td><code>sonar.java.test.libraries</code></td>\n<td><code>${sourceSets.test.compileClasspath}</code> (filtering to only include files; rt.jar and jfxrt.jar added if necessary)</td>\n</tr>\n<tr>\n<td><code>sonar.junit.reportPaths</code></td>\n<td><code>${test.testResultsDir}</code> (if the directory exists)</td>\n</tr>\n</tbody>\n</table>\n<p>Groovy projects get all the Java defaults, plus:</p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Gradle default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>sonar.groovy.binaries</code></td>\n<td><code>${sourceSets.main.output.classesDir}</code></td>\n</tr>\n</tbody>\n</table>\n<p>Additional defaults when JaCoCo plugin is applied</p>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Gradle default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>sonar.jacoco.reportPaths</code></td>\n<td><code>${jacoco.destinationFile}</code></td>\n</tr>\n<tr>\n<td><code>sonar.groovy.jacoco.reportPath</code></td>\n<td><code>${jacoco.destinationFile}</code></td>\n</tr>\n</tbody>\n</table>\n<p>Additional defaults for Android projects (<code>com.android.application</code>, <code>com.android.library</code>, or <code>com.android.test</code>)\nBy default the first variant of type \"debug\" will be used to configure the analysis. You can override the name of the variant to be used using the parameter 'androidVariant':</p>\n<pre><code>build.gradle\nsonarqube {\n    androidVariant 'fullDebug'\n}\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>Property</th>\n<th>Gradle default</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>sonar.sources</code> (for non test variants)</td>\n<td><code>${variant.sourcesets.map}</code> (ManifestFile/CDirectories/AidlDirectories/AssetsDirectories/CppDirectories/JavaDirectories/RenderscriptDirectories/ResDirectories/ResourcesDirectories)</td>\n</tr>\n<tr>\n<td><code>sonar.tests</code> (for test variants)</td>\n<td><code>${variant.sourcesets.map}</code> (ManifestFile/CDirectories/AidlDirectories/AssetsDirectories/CppDirectories/JavaDirectories/RenderscriptDirectories/ResDirectories/ResourcesDirectories)</td>\n</tr>\n<tr>\n<td><code>sonar.java[.test].binaries</code></td>\n<td><code>${variant.destinationDir}</code></td>\n</tr>\n<tr>\n<td><code>sonar.java[.test].libraries</code></td>\n<td><code>${variant.javaCompile.classpath} + ${bootclasspath}</code></td>\n</tr>\n<tr>\n<td><code>sonar.java.source</code></td>\n<td><code>${variant.javaCompile.sourceCompatibility}</code></td>\n</tr>\n<tr>\n<td><code>sonar.java.target</code></td>\n<td><code>${variant.javaCompile.targetCompatibility}</code></td>\n</tr>\n</tbody>\n</table>\n<h2>Passing manual properties / overriding defaults</h2>\n<p>The SonarScanner for Gradle adds a SonarQubeExtension extension to project and its subprojects, which allows you to configure/override the analysis properties.</p>\n<pre><code>// in build.gradle\nsonarqube {\n    properties {\n        property \"sonar.exclusions\", \"**/*Generated.java\"\n    }\n}\n</code></pre>\n<p>SonarQube properties can also be set from the command line, or by setting a system property named exactly like the SonarQube property in question. This can be useful when dealing with sensitive information (e.g. credentials), environment information, or for ad-hoc configuration.</p>\n<pre><code>gradle sonarqube -Dsonar.host.url=http://sonar.mycompany.com -Dsonar.verbose=true\n</code></pre>\n<p>While certainly useful at times, we recommend keeping the bulk of the configuration in a (versioned) build script, readily available to everyone.\nA SonarQube property value set via a system property overrides any value set in a build script (for the same property). When analyzing a project hierarchy, values set via system properties apply to the root project of the analyzed hierarchy. Each system property starting with <code>sonar.</code> will be taken into account.</p>\n<h3>Analyzing Custom Source Sets</h3>\n<p>By default, the SonarScanner for Gradle passes on the project's main source set as production sources, and the project's test source set as test sources. This works regardless of the project's source directory layout. Additional source sets can be added as needed.</p>\n<pre><code>// build.gradle\nsonarqube {\n    properties {\n        properties[\"sonar.sources\"] += sourceSets.custom.allSource.srcDirs\n        properties[\"sonar.tests\"] += sourceSets.integTest.allSource.srcDirs\n    }\n}\n</code></pre>\n<h2>Advanced topics</h2>\n<h3>More on configuring SonarQube properties</h3>\n<p>Let's take a closer look at the <code>sonarqube.properties</code> <code>{}</code> block. As we have already seen in the examples, the <code>property()</code> method allows you to set new properties or override existing ones. Furthermore, all properties that have been configured up to this point, including all properties preconfigured by Gradle, are available via the properties accessor.</p>\n<p>Entries in the properties map can be read and written with the usual Groovy syntax. To facilitate their manipulation, values still have their “idiomatic” type (File, List, etc.). After the sonarProperties block has been evaluated, values are converted to Strings as follows: Collection values are (recursively) converted to comma-separated Strings, and all other values are converted by calling their <code>toString()</code> methods.</p>\n<p>Because the <code>sonarProperties</code> block is evaluated lazily, properties of Gradle's object model can be safely referenced from within the block, without having to fear that they have not yet been set.</p>"}