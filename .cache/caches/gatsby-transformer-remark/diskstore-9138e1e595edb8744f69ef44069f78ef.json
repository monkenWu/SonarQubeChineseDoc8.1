{"expireTime":9007200870884090000,"key":"transformer-remark-markdown-html-2e7eade65e6af46e8d865c8ed28c7c44-gatsby-remark-custom-blocks-/SonarQubeChineseDoc8.1","val":"<p><em>Cobol analysis is available as part of the <a href=\"https://redirect.sonarsource.com/editions/enterprise.html\">Enterprise Edition</a> and <a href=\"https://redirect.sonarsource.com/editions/editions.html\">above</a>.</em></p>\n<!-- update_center:cobol -->\n<h2>Language-Specific Properties</h2>\n<p>You can discover and update the COBOL-specific <a href=\"/SonarQubeChineseDoc8.1/analysis/analysis-parameters/\">properties</a> in: <strong><a href=\"/SonarQubeChineseDoc8.1/#sonarqube-admin#/admin/settings?category=cobol\">Administration > General Settings > Cobol</a></strong></p>\n<h2>Source Code Extraction</h2>\n<p>In order to analyze your source code with SonarQube you need to first extract it onto a filesystem. You can use your own tool or an open source tool; SonarSource does not provide any connectors or source code extraction tools.</p>\n<h2>Advanced Configuration</h2>\n<h3>Defining Source Code Format</h3>\n<p>The supported source code formats are:</p>\n<ul>\n<li>Fixed format</li>\n<li>Free format</li>\n<li>Variable format</li>\n</ul>\n<p>To set the format, go to <strong><a href=\"/SonarQubeChineseDoc8.1/#sonarqube-admin#/admin/settings?category=cobol\">Administration > General Settings > Cobol</a></strong> and set the \"Source format\" property.</p>\n<p>The fixed format has three main areas:</p>\n<pre><code>Area1 | Area2                                           | Area3\n000100* MY COMMENT\n000100 IDENTIFICATION DIVISION.\n000200 PROGRAM-ID. HELLOWORLD.                          *xxx\n100000 PROCEDURE DIVISION.                              *yyy\n100100\n100200 START.\n100400 DISPLAY \"HELLO COBOL !\" LINE 42 POSITION 12.\n100500 STOP RUN.\n</code></pre>\n<p>Areas #1 and #3 contain non-significant characters.\nArea #2 contains the source code. The first character of Area #2 is the Indicator Area, which has a special meaning (for instance <code>*</code> means that the line is a comment line, <code>D</code> means that the line is only taken into account in debug mode, etc.).</p>\n<p>The free format:</p>\n<pre><code>Area1 | Area2\n      * MY COMMENT\n       IDENTIFICATION DIVISION.\n         PROGRAM-ID. HELLOWORLD.\n       PROCEDURE DIVISION.\n         DISPLAY \"HELLO COBOL !\" LINE 42 POSITION 12.\n         STOP RUN.\n</code></pre>\n<p>The Indicator Area that has a special meaning (for instance <code>*</code> means that the line is a comment line, <code>D</code> means that the line in only taken into account in debug mode, etc.) is located at column 0. The size of the source code area is not limited.</p>\n<p>Variable format is also supported: it's similar to the fixed format but without Area #3.</p>\n<h3>Defining COBOL Dialect</h3>\n<p>Go to <strong><a href=\"/SonarQubeChineseDoc8.1/#sonarqube-admin#/admin/settings?category=cobol\">Administration > General Settings > Cobol</a></strong> and set the \"Dialect\" property.</p>\n<p>The COBOL analyzer supports the following dialects:</p>\n<ul>\n<li><code>bull-gcos-cobol</code></li>\n<li><code>hp-tandem-cobol</code></li>\n<li><code>ibm-os/vs-cobol</code></li>\n<li><code>ibm-ile-cobol</code></li>\n<li><code>ibm-cobol/ii</code></li>\n<li><code>ibm-cobol/400</code></li>\n<li><code>ibm-enterprise-cobol</code></li>\n<li><code>microfocus-cobol</code></li>\n<li><code>microfocus-acucobol-gt-cobol</code></li>\n<li><code>opencobol/cobol-it</code></li>\n</ul>\n<h3>Making Copybooks Available to the Analysis</h3>\n<p>Copybooks are, by definition, COBOL files that are not syntactically valid by themselves. However, copybooks are usually needed to properly parse COBOL programs. Thus, paths to the copybooks must be listed through the <code>sonar.cobol.copy.directories</code> property.</p>\n<h3>Raising Issues Against Copybooks</h3>\n<p>To have copybooks imported into a project, and issues logged against them, the copybook directories must be added to <code>sonar.sources</code> AND the copybook file suffixes must be added to <code>sonar.cobol.file.suffixes</code>. E.G.:</p>\n<pre><code>sonar.sources=cobol,copy1,commonCopy\nsonar.cobol.file.suffixes=cbl,cpy\nsonar.cobol.copy.suffixes=cpy\nsonar.cobol.copy.directories=copy1,commonCopy\n</code></pre>\n<p>In the case where a number of projects share a common set of copybooks, it may not be desirable to increment each project’s technical debt with the issues from the common copybooks. In such cases, the directory holding the common copybooks should be listed in <code>sonar.cobol.copy.directories</code> (as before) but left out of sonar.sources, E.G.:</p>\n<pre><code>sonar.sources=cobol,copy1\nsonar.cobol.file.suffixes=cbl,cpy\nsonar.cobol.copy.suffixes=cpy\nsonar.cobol.copy.directories=copy1,commonCopy\n</code></pre>\n<h3>Analyzing without file suffixes</h3>\n<p>Note that it is possible to analyze a COBOL project without file suffixes. To do this, remove the two suffix-related properties from your configuration and substitute the following setting for <code>sonar.lang.patterns.cobol</code>:</p>\n<pre><code>sonar.lang.patterns.cobol=**/*\n</code></pre>\n<h3>Switching Off Issues</h3>\n<p>There are three ways to switch off issues:</p>\n<ul>\n<li>Flagging issues as <a href=\"/SonarQubeChineseDoc8.1/user-guide/issues/\">false positive</a></li>\n<li><a href=\"/SonarQubeChineseDoc8.1/project-administration/narrowing-the-focus/\">Ignoring the issues</a></li>\n<li>Using the <code>NOSONAR</code> tag. To switch off an issue, place the <code>NOSONAR</code> tag in a comment line located right before the line containing the issue. Example:</li>\n</ul>\n<pre><code>* NOSONAR, in such case call to GO TO is tolerated, blabla...\n GO TO MY_PARAGRAPH.\n</code></pre>\n<h3>ACUCOBOL-GT Source Code Control Directives</h3>\n<p>The COBOL analyzer supports the ACUCOBOL-GT’s Source Code Control directives. This mechanism allows you to conditionally modify the program at compile time by excluding or including lines. This can be used to maintain different versions of the program, perhaps to support different machine environments.</p>\n<p>The <code>-Si</code> (include) flag controls the actions of the source code control system. It must be followed by an argument that specifies a pattern that the compiler will search for in the Identification Area of each source line. If the pattern is found, then the line will be included in the source program, even if it is a comment line. However, if the pattern is immediately preceded by an exclamation point, then the line will be excluded from the source (i.e., commented out).</p>\n<p>The <code>-Sx</code> (exclude) flag works the same way except that its meaning is reversed (lines with the pattern will be commented out and lines with a preceding exclamation point will be included).</p>\n<p>For example, suppose a program is being maintained for both the UNIX and VMS environments. The following piece of code is in the program:</p>\n<pre><code>MOVE \"SYS$HELP:HELPFILE\" TO FILE-NAME.  VMS\n*MOVE \"/etc/helpfile\" TO FILE-NAME.     UNX\nOPEN INPUT HELP-FILE.\n</code></pre>\n<p>This program fragment is ready to be compiled for the VMS system. If a UNIX version is desired, then the following flags will correct the source during compilation:</p>\n<pre><code>-Si UNX -Sx VMS\n</code></pre>\n<p>Please consult the ACUCOBOL-GT documentation for more on the mechanism.</p>\n<p>There are two ways in SonarQube to specify the list of ACUCOBOL-GT flags to be used in order to preprocess the source code. The first option is to define a list of global flags which will be used to preprocess all source files. This can be done in the <strong><a href=\"/SonarQubeChineseDoc8.1/#sonarqube-admin#/admin/settings?category=cobol\">Administration > General Settings > Cobol</a> > Preprocessor</strong>.</p>\n<p>The second option is to provide a list of relative paths (with help of the ‘sonar.cobol.acucobol.preprocessor.directives.directories’ property) which contain the list of flags to be used for each COBOL source file. Let’s take a simple example. If a file ‘MY<em>PROGRAM.CBL’ is going to be processed, the SonarQube ACUCOBOL-GT preprocessor, will try to find a file ‘MY</em>PROGRAM.CMD’. If this file is found, then the flags contained in this file is going to be used to preprocess the program ‘MY<em>PROGRAM.CBL’. If the file ‘MY</em>PROGRAM.CMD’ doesn’t exist, then the preprocess will use the content of the file ‘DEFAULT.CMD’ if exists.</p>\n<h3>Microfocus Compiler Constants</h3>\n<p>If your code takes advantage of conditional compilation features provided by Microfocus, you may have to configure compiler constants for your analysis. You can define a compiler constant by setting a property named s<code>onar.cobol.compilationConstant.[constant name here].</code></p>\n<p>For example, if your COBOL code looks like this:</p>\n<pre><code>       IDENTIFICATION DIVISION.\n      $IF myconstant DEFINED\n       PROGRAM-ID. x.\n      $END\n      $IF otherconstant DEFINED\n       PROGRAM-ID. y.\n      $END\n</code></pre>\n<p>You can set the value of a compiler constant named \"myconstant\" by inserting the following line in your sonar-project.properties file:</p>\n<pre><code>sonar.cobol.compilationConstant.myconstant=myvalue\n</code></pre>\n<h2>Database Catalog (DB2)</h2>\n<p>The COBOL analyzer offers rules which target embedded SQL statements and require the analyzer to have knowledge of the database catalog (E.G. the primary key column(s) of a given table).\nThese rules will raise issues only if the database catalog is provided to the analysis. For the moment, this is available only for IBM DB2 (z/OS) catalogs, and the catalog must be provided via a set of CSV (\"Comma Separated Values\") files.</p>\n<p>These rules rely on two analysis properties:</p>\n<table>\n<thead>\n<tr>\n<th>Key</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>sonar.cobol.sql.catalog.csv.path</code></td>\n<td>relative path of the directory containing CSV files for the database catalog</td>\n</tr>\n<tr>\n<td><code>sonar.cobol.sql.catalog.defaultSchema</code></td>\n<td>comma-separated list of default database schemas used in embedded SQL statements</td>\n</tr>\n</tbody>\n</table>\n<p><code>sonar.cobol.sql.catalog.csv.path</code> should define a directory which contains 8 CSV files. Each of these CSV files contains data for a specific DB2 catalog table and is named after it. The following table lists the required files and their respective mandatory columns. Additional columns may be listed, but will be ignored:</p>\n<table>\n<thead>\n<tr>\n<th>Table</th>\n<th>File name</th>\n<th>Required Columns</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>SYSIBM.SYSCOLUMNS</code></td>\n<td><code>SYSCOLUMNS.csv</code></td>\n<td><code>TBNAME</code>,<code>TBCREATOR</code>,<code>NAME</code>,<code>PARTKEY_COLSEQ</code>,<code>DEFAULT</code>,<code>NULLS</code>,<code>DEFAULTVALUE</code></td>\n</tr>\n<tr>\n<td><code>SYSIBM.SYSINDEXES</code></td>\n<td><code>SYSINDEXES.csv</code></td>\n<td><code>NAME</code>,<code>CREATOR</code>,<code>TBNAME</code>,<code>TBCREATOR</code>,<code>UNIQUERULE</code>,<code>INDEXTYPE</code></td>\n</tr>\n<tr>\n<td><code>SYSIBM.SYSINDEXPART</code></td>\n<td><code>SYSINDEXPART.csv</code></td>\n<td><code>IXNAME</code>,<code>IXCREATOR</code>,<code>PARTITION</code></td>\n</tr>\n<tr>\n<td><code>SYSIBM.SYSKEYS</code></td>\n<td><code>SYSKEYS.csv</code></td>\n<td><code>IXNAME</code>,<code>IXCREATOR</code>,<code>COLNAME</code>,<code>COLSEQ</code></td>\n</tr>\n<tr>\n<td><code>SYSIBM.SYSSYNONYMS</code></td>\n<td><code>SYSSYNONYMS.csv</code></td>\n<td><code>NAME</code>,<code>CREATOR</code>,<code>TBNAME</code>,<code>TBCREATOR</code></td>\n</tr>\n<tr>\n<td><code>SYSIBM.SYSTABLES</code></td>\n<td><code>SYSTABLES.csv</code></td>\n<td><code>NAME</code>,<code>CREATOR</code>,<code>TYPE</code>,<code>PARTKEYCOLNUM</code>,<code>TSNAME</code>,<code>DBNAME</code>,<code>TBNAME</code>,<code>TBCREATOR</code>,<code>CARDF</code></td>\n</tr>\n<tr>\n<td><code>SYSIBM.SYSTABLESPACE</code></td>\n<td><code>SYSTABLESPACE.csv</code></td>\n<td><code>NAME</code>,<code>DBNAME</code>,<code>PARTITIONS</code></td>\n</tr>\n<tr>\n<td><code>SYSIBM.SYSVIEWS</code></td>\n<td><code>SYSVIEWS.csv</code></td>\n<td><code>NAME</code>,<code>CREATOR</code>,<code>STATEMENT</code></td>\n</tr>\n</tbody>\n</table>\n<p>The CSV format is the following:</p>\n<ul>\n<li>Each file must be named for the table it represents.</li>\n<li>First line must contain the exact names of the columns.</li>\n<li>Order of the columns is not meaningful.</li>\n<li>Fields are comma-delimited.</li>\n<li>If a field contains a comma, then its value must be surrounded by double quotes (\").</li>\n<li>If a field which is surrounded by double quotes contains a double quote character (\"), then this character must be doubled (\"\").</li>\n</ul>\n<p>Example for <code>SYSVIEWS.csv</code>:</p>\n<pre><code>CREATOR,NAME,STATEMENT\nUSER1,VIEW1,select x from table1\nUSER1,VIEW2,\"select x, y from table1\"\nUSER1,VIEW3,\"select x, \"\"y\"\" from table1\"\n</code></pre>\n<p>The <code>UNLOAD</code> DB2 utility with the <code>DELIMITED</code> option should produce the required files except for the column names on the first line.</p>\n<h2>Custom Rules</h2>\n<h3>Overview</h3>\n<p>The COBOL analyzer parses the source code, creates an Abstract Syntax Tree (AST) and then walks through the entire tree. A coding rule can subscribe to be notified every time a node of a certain type is visited.</p>\n<p>As soon as the coding rule is notified, it can navigate the tree around the node and raise issues if necessary.</p>\n<h3>Writing a Plugin</h3>\n<p>Writing new COBOL coding rules is a six-step process:</p>\n<ul>\n<li>Create a standard SonarQube plugin.</li>\n<li>Attach this plugin to the SonarQube COBOL plugin (see the <code>pom.xml</code> file of the provided sample plugin project).</li>\n<li>Create as many custom COBOL coding rules as required by extending <code>com.sonarsource.api.ast.CobolCheck</code> and add them to the previous repository.</li>\n<li>Generate the SonarQube plugin (jar file).</li>\n<li>Place this jar file in the <code>$SONARQUBE_HOME/extensions/plugins</code> directory.</li>\n<li>Restart the SonarQube server.</li>\n</ul>\n<h3>Plugin Project Sample</h3>\n<p>To get started, clone the sample plugin project and follow the steps below:</p>\n<ul>\n<li>Install Maven</li>\n<li>Build the plugin by running <code>mvn install</code> from the project directory. This will generate a SonarQube plugin jar file in the target directory.</li>\n<li>Add your newly created jar into the <code>$SONARQUBE_HOME/extensions/plugins</code> directory</li>\n<li>Restart the SonarQube server</li>\n</ul>\n<p>If you now look at the COBOL quality profiles, you will find the new coding rule (“Sample check”). Don’t forget to activate it. Run an analysis of a COBOL project, and you will find that an issue was logged at line 5 on every file.</p>\n<h3>Subscribing to a NodeType</h3>\n<p>Very often when writing a coding rule, you will want to subscribe to a NodeType. A NodeType can be either a rule of the grammar or a keyword of the language. As an example, here is the code of the implementation of the “Avoid using Merge statement” coding rule:</p>\n<pre><code>public class MergeStatementUsageCheck extends CobolCheck {\n\n  public void init() {\n    subscribeTo(getCobolGrammar().mergeStatement);\n  }\n\n  public void visitNode(AstNode node) {\n    reportIssue(\"Avoid using MERGE statement.\").on(node);\n  }\n}\n</code></pre>\n<p>Note that CICS and SQL grammars can be accessed using <code>getCicsGrammar()</code> and <code>getSqlGrammar()</code>.</p>\n<h3>Coding Rule Lifecycle</h3>\n<p>A coding rule can optionally override six methods inherited from the CobolCheck class. Those methods are called sequentially in the following order:</p>\n<ul>\n<li><code>public void init() {…}</code>: This method is called only once and should be used to subscribe to one or more NodeType(s).</li>\n<li><code>public void visitFile(AstNode astNode) {…}</code>: This method is called on each file before starting the parsing.</li>\n<li><code>public void visitNode(AstNode astNode) {…}</code>: This method is called when an AstNode matches a subscribed NodeType (see Subscribing to a NodeType) and before analyzing its content.</li>\n<li><code>public void leaveNode(AstNode astNode) {…}</code>: This method is called when an AstNode matches a desired NodeType (see Subscribing to a NodeType) and after analyzing its content.</li>\n<li><code>public void leaveFile(AstNode astNode) {…}</code>: This method is called before exiting a file.</li>\n<li><code>public void destroy() {…}</code>: This method is called before shutting down the coding rule.</li>\n<li>The <code>reportIssue(…)</code> method, used to log an issue, should be called only inside the <code>visitFile(…)</code>, <code>visitNode(…)</code>, <code>leaveNode(…)</code> and <code>leaveFile(…)</code> methods. Indeed, the file context isn’t known when the <code>init()</code> and <code>destroy()</code> methods are called, so the issue can’t be associated to a file.</li>\n</ul>\n<p>More advanced features are documented in the <a href=\"http://javadocs.sonarsource.org/cobol/apidocs/\">API Javadoc</a>.</p>\n<h3>Navigating the AST (Abstract Syntax Tree) with the SSLR COBOL Toolkit</h3>\n<p>When starting to write a new COBOL coding rule, the main difficulty is to understand the COBOL AST in order to know which NodeType(s) need to be visited. This can be achieved by using the <a href=\"https://binaries.sonarsource.com/CommercialDistribution/sslr-cobol-toolkit/\">SSLR COBOL Toolkit</a>, a Swing application that enables loading a COBOL file and displaying its representation as an Abstract Syntax Tree.</p>\n<p>Each node in the AST is a COBOL grammar rule and each leaf in the AST is a COBOL token. Let’s say you want to visit the node <code>ifStatement</code>. In this case, the <code>init()</code> method of your COBOL coding rule must contain the following statement: <code>subscribeTo(getCobolGrammar().ifStatement);</code></p>\n<h3>API Changes</h3>\n<p><em>Since 4.0</em>\nA new API is available to write the rules but also to implement the tests.</p>\n<p>Custom rules should now extend <code>CobolCheck</code> (<code>CobolAstCheck</code> is deprecated) and issues should be logged using the <code>reportIssue(...)</code> method.<br>\nTests on custom rules should now use <code>CobolCheckVerifier</code>: the assertions about issues should now be added as comments inside COBOL test files.<br>\nCustom rules should be listed in an implementation of <code>CobolCheckRepository</code> (<code>CobolAstCheckRepository</code> is now deprecated) and metadata should be loaded by implementing <code>RulesDefinitionExtension</code>.<br>\nYou can now store your custom rules into a dedicated rule repository by implementing SonarQube's <code>RulesDefinition</code>: in that case, you don't need to implement <code>RulesDefinitionExtension</code>.<br>\n<img src=\"/images/exclamation.svg\"> For users who already have custom rules in production: existing issues will be closed and re-opened because the internal keys of the rules are changing.\nIf you wrote a custom plugin against SonarCOBOL 3.x, it should still be compatible at runtime with SonarCOBOL 4.0.</p>\n<p>To migrate to the new API (<a href=\"https://github.com/SonarSource/sonar-custom-rules-examples/pull/14\">full example on github</a>):</p>\n<ul>\n<li>First, migrate tests without modifying rule classes. That mainly requires moving assertions from java test classes to comments inside test cobol files (<a href=\"https://github.com/SonarSource/sonar-custom-rules-examples/commit/c95b6a84b6fd1efc832a46cd5e1101ee51e6268e\">see an example on github</a>).</li>\n<li>Update check classes to replace the calls to deprecated methods with the new methods which create issues (<a href=\"https://github.com/SonarSource/sonar-custom-rules-examples/commit/d6f6ef7457d99e31990fa64b5ff9cc566775af96\">see an example on github</a>).</li>\n<li>Implement <code>CobolRulesDefinitionExtension</code> and <code>CobolCheckRepository</code>, remove the class extending <code>CobolAstCheckRepository</code> (<a href=\"https://github.com/SonarSource/sonar-custom-rules-examples/commit/ea15f07ce79366a08fee5b60e9a93c32a4625918\">see an example on github</a>).</li>\n<li>Update check classes to extend <code>CobolCheck</code> instead of <code>CobolAstCheck</code> to stop using deprecated APIs (<a href=\"https://github.com/SonarSource/sonar-custom-rules-examples/commit/8e1d746900f5411e9700fea04700cd804e45e034\">see an example on github</a>).</li>\n</ul>\n<p>To move your custom rules to a dedicated rule repository, see <a href=\"https://github.com/SonarSource/sonar-custom-rules-examples/commit/16ad89c4172c259f15bce56edcd09dd5b489eacd\">an example on github</a>.</p>\n<h2>Related Pages</h2>\n<ul>\n<li>\n<p><a href=\"/SonarQubeChineseDoc8.1/extend/adding-coding-rules/\">Adding Coding Rules</a></p>\n</li>\n</ul>"}