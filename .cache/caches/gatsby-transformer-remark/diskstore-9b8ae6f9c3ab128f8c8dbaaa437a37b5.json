{"expireTime":9007200870884089000,"key":"transformer-remark-markdown-html-b39c3a7238649cbaf2907d9fb2fb01a4-gatsby-remark-custom-blocks-/SonarQubeChineseDoc8.1","val":"<p><em>C/C++/Objective-C analysis is available as part of <a href=\"https://redirect.sonarsource.com/editions/developer.html\">Developer Edition</a> and <a href=\"https://redirect.sonarsource.com/editions/editions.html\">above</a>.</em></p>\n<!-- update_center:cpp -->\n<p>C/C++/Objective-C analysis is officially registered as <a href=\"https://cwe.mitre.org/compatible/\">CWE Compatible</a>.</p>\n<h2>Supported Compilers, Language Standards and Operating Systems</h2>\n<ul>\n<li>Any version of Clang, GCC and Microsoft C/C++ compilers</li>\n<li>Any version of Intel compiler for Linux and macOS</li>\n<li>ARM5 and ARM6 compilers</li>\n<li>IAR compiler for ARM, Renesas RL78, Renesas RX, Renesas V850, Texas Instruments MSP430 and for 8051</li>\n<li>Compilers based wholly on GCC including for instance Linaro GCC and WindRiver GCC are also supported</li>\n<li>C89, C99, C11, C++03, C++11, C++14 and C++17 standards</li>\n<li>GNU extensions</li>\n<li>Microsoft Windows, Linux and macOS for runtime environment</li>\n</ul>\n<h2>Language-Specific Properties</h2>\n<p>Discover and update the C/C++/Objective-C specific properties in: <strong><a href=\"/SonarQubeChineseDoc8.1/#sonarqube-admin#/admin/settings?category=c+%2F+c%2B%2B+%2F+objective-c\">Administration > General Settings > C / C++ / Objective-C</a></strong></p>\n<h2>Prerequisites</h2>\n<h3>Build Wrapper</h3>\n<p>Analysis of C/C++/Objective-C projects requires the <strong>SonarQube Build Wrapper</strong>. It gathers all the configuration required for correct analysis of C/C++/Objective-C projects (such as macro definitions, include directories, â€¦) directly from your project's build process. The Build Wrapper does not impact your build; it merely eavesdrops on it and writes what it learns into files a directory you specify. </p>\n<p>You can download the <em>Build Wrapper</em> directly from your SonarQube server, so that its version perfectly matches your version of the plugin. </p>\n<ul>\n<li>Download <em>Build Wrapper</em> for Linux from <a href=\"/SonarQubeChineseDoc8.1/#sonarqube#/static/cpp/build-wrapper-linux-x86.zip\">{SonarQube URL}/static/cpp/build-wrapper-linux-x86.zip</a></li>\n<li>Download <em>Build Wrapper</em> for macOS from <a href=\"/SonarQubeChineseDoc8.1/#sonarqube#/static/cpp/build-wrapper-macosx-x86.zip\">{SonarQube URL}/static/cpp/build-wrapper-macosx-x86.zip</a></li>\n<li>Download <em>Build Wrapper</em> for Windows from <a href=\"/SonarQubeChineseDoc8.1/#sonarqube#/static/cpp/build-wrapper-win-x86.zip\">{SonarQube URL}/static/cpp/build-wrapper-win-x86.zip</a></li>\n</ul>\n<p>Unzip the downloaded <em>Build Wrapper</em> and configure it in your <code>PATH</code> because doing so is just more convenient.</p>\n<h3>SonarQube Scanner</h3>\n<p>Analysis of C/C++/Objective-C projects requires the <a href=\"https://redirect.sonarsource.com/doc/install-configure-scanner.html\"><em>SonarScanner</em></a> CLI.</p>\n<h2>Analysis Steps</h2>\n<ul>\n<li>\n<p>If you use macOS or Linux operating systems make sure your source tree is in a directory called <code>src</code></p>\n</li>\n<li>\n<p>Add execution of the <em>Build Wrapper</em> as a prefix to your usual build command (the examples below use <code>make</code>, <code>xcodebuild</code> and <code>MSBuild</code>, but any build tool that performs a full build can be used)</p>\n<pre><code>// example for linux\nbuild-wrapper-linux-x86-64 --out-dir build_wrapper_output_directory make clean all \n// example for macOS\nbuild-wrapper-macosx-x86 --out-dir build_wrapper_output_directory xcodebuild clean build\n// example for Windows\nbuild-wrapper-win-x86-64.exe --out-dir  build_wrapper_output_directory MSBuild.exe /t:Rebuild\n</code></pre>\n</li>\n<li>\n<p>In the <em>sonar-project.properties</em> file at the root of your project add the property <code>sonar.cfamily.build-wrapper-output</code> with the path to the <em>Build Wrapper</em> output directory relative to the project directory (<code>build_wrapper_output_directory</code> in these examples). </p>\n<p>Sample <em>sonar-project.properties</em>:</p>\n<pre><code>sonar.projectKey=myFirstProject\nsonar.projectName=My First C++ Project\nsonar.projectVersion=1.0\nsonar.sources=src\nsonar.cfamily.build-wrapper-output=build_wrapper_output_directory\nsonar.sourceEncoding=UTF-8\n</code></pre>\n</li>\n<li>\n<p>Execute the SonarScanner (<code>sonar-scanner</code>) from the root directory of the project</p>\n<pre><code>sonar-scanner\n</code></pre>\n</li>\n<li>\n<p>Follow the link provided at the end of the analysis to browse your project's quality metrics in the UI</p>\n</li>\n</ul>\n<h2>Multithreaded Code Scan</h2>\n<p>It is possible to use all the cores available on the machine running the code scan. This can be activated by configuring the property <code>sonar.cfamily.threads</code> at the scanner level. Its default value is 1.</p>\n<ul>\n<li>\n<p>This feature must not be activated on a machine with only 1 core.</p>\n</li>\n<li>\n<p>The analyzer will not guess which value is most suitable for your project. It's up to you to test and find the best value.</p>\n</li>\n<li>\n<p>If a build machine with 2 cores is already configured to potentially run two code scans at the same time, there is no guarantee that configuring <code>sonar.cfamily.threads=2</code> will bring the expected performance benefits. It can even be worse than running with the default value.</p>\n</li>\n<li>\n<p>The multithreaded execution requires more memory than single-threaded execution.</p>\n</li>\n<li>\n<p>A machine with 64 cores configured with <code>sonar.cfamily.threads=64</code> is not certain to bring a large performance gain compared to a machine with 32 cores. The performance tradeoff will vary depending on the machine, project and setup, so some testing will be required to decide if the performance gain justifies moving to a larger machine.</p>\n</li>\n</ul>\n<h2>Solution with a Mix of C# and C++</h2>\n<p>When you have a Solution made of C++ and C#, to both use the SonarQube <em>Build Wrapper</em> and have an accurate analysis of the C# code, you must to use the <a href=\"https://github.com/SonarSource/sonar-scanner-msbuild\">SonarScanner for MSBuild</a>.\nNote that in this scenario source code stored in shared folders, not considered as a \"Project\" by Visual Studio, won't be scanned.</p>\n<ul>\n<li>Download and install both the <a href=\"https://redirect.sonarsource.com/doc/install-configure-scanner-msbuild.html\">SonarScanner for MSBuild</a> and the SonarQube <em>Build Wrapper</em> (see <em>Prerequisites</em> section).</li>\n<li>Execute the SonarQube Scanner for MSBuild <code>begin</code> step</li>\n<li>Add execution of <em>Build Wrapper</em> to your normal MSBuild build command</li>\n<li>Execute the SonarQube Scanner for MSBuild <code>end</code> step to complete the analysis</li>\n</ul>\n<p>For example:</p>\n<pre><code>SonarScanner.MSBuild.exe begin /k:\"cs-and-cpp-project-key\" /n:\"My C# and C++ project\" /v:\"1.0\" /d:sonar.cfamily.build-wrapper-output=\"bw_output\"\nbuild-wrapper-win-x86-64.exe --out-dir bw_output MSBuild.exe /t:Rebuild\nSonarScanner.MSBuild.exe end\n</code></pre>\n<h2>Measures for Header Files</h2>\n<p>Each time we analyze a header file as part of a compilation unit, we compute for this header the measures: statements, functions, classes, cyclomatic complexity and cognitive complexity. That means that each measure may be computed more than once for a given header. In that case, we store the largest value for each measure.</p>\n<h2>Building with Bazel</h2>\n<p><a href=\"https://www.bazel.build/\">Bazel</a> recommends that you use the <a href=\"https://docs.bazel.build/versions/master/bazel-user-manual.html#flag--batch\"><code>--batch</code></a> option when running in a Continuous Build context. When using the <em>BuildWrapper</em>, you are in such context. Also, you need to deactivate the <a href=\"https://docs.bazel.build/versions/master/bazel-user-manual.html#sandboxing\">\"sandbox\"</a> mechanism of <em>Bazel</em> so that the compiled file paths could be retrieved after the compilation phase.\nHere is an example of the <em>BuildWrapper</em> command with Bazel parameters on macOS:</p>\n<pre><code>build-wrapper-macosx-x86 --out-dir bw bazel\n  --batch\n  --spawn_strategy=standalone\n  --genrule_strategy=standalone\n  --bazelrc=/dev/null build\n  //main:hello-world\n</code></pre>\n<h2>Related Pages</h2>\n<ul>\n<li><a href=\"/SonarQubeChineseDoc8.1/analysis/coverage/\">Test Coverage &#x26; Execution</a> (CPPUnit, GCOV, llvm-cov, Visual Studio, Bullseye)</li>\n<li><a href=\"https://github.com/SonarSource/sonar-scanning-examples/tree/master/sonarqube-scanner-build-wrapper-linux\">Sample project</a> for C/C++ (Linux)</li>\n<li><a href=\"https://github.com/SonarSource/sonar-scanning-examples/tree/master/objc-llvm-coverage\">Sample project</a> for Objective-C</li>\n<li><a href=\"https://redirect.sonarsource.com/doc/install-configure-scanner-tfs-ts.html\">SonarScanner for Azure Devops</a> (analyzing Visual C++ project)</li>\n</ul>"}